<!doctype html>
<html lang="fr">
	<head>
  		<meta charset="utf-8">
  		<title>Mower Haskell</title>
	</head>
	<body>
		<h1>Mower Haskell</h1>
		<fieldset>
			<legend>But de l'exercice</legend>
			<p>
				Le but de cet exercice est de réaliser l'exercice de la tondeuse, en utilisant le langage Haskell, donc en étant confronté au paradigme purement fonctionnel.
			</p>
		</fieldset>
		<p>
			Le site <a href="http://www.haskell.org/hoogle/"/>Hoogle</a> est indispensable. Il documente toutes les fonctions de la librairie standard. La particularité de ce dictionnaire est qu'il permet des recherches par signature. Ainsi, il est possible de rechercher toutes les fonctions contenant la signature [a] -> a, par exemple.
		</p>
		<fieldset>
			<legend>Cabal</legend>
			<p>
				Cabal est l'outil permettant d'automatiser la gestion des dépendances, le build des modules et du programme, et l'exécution des tests unitaires.
				Il n'y a normalement rien à modifier dans la configuration du projet Cabal <i>(fichier mower.cabal)</i>.
			</p>
			<p>
				Ces commandes te seront utiles :
				<ul>
					<li><code>cabal configure --enable-test</code></li>
					<li><code>cabal build</code></li>
					<li><code>cabal test</code></li>
				</ul>
				L'exécutable se trouve alors dans le répertoire dist/build/Mower/, et se nomme <i>mower</i>. La commande <i>cabal build</i> doit être lancée après chaque modification de code, si tu souhaites exécuter le programme mower. La commande <i>cabal configure --enable-test</i> peut être exécuter une seule et unique fois au début.
			</p>
			<p>
				Le projet mower-haskell est formé de trois composants :
				<ul>
					<li>Le module <code>Mower.Core</code>, dans lequel tu devras implémenter un ensemble de types et de fonctions</li>
					<li>La fonction <code>main</code>, déjà implémentée, dans laquelle se trouve le code de l'exécutable, et qui utilise notamment le module <code>Mower.Core</code></li>
					<li>Les tests unitaires, déjà implémentés, t'aideront à l'implémentation du code</li>
				</ul>
			</p>
		</fieldset>
		<br />
		<fieldset>
			<legend>Maintenant, on code (sans effet de bord :)</legend>
			<span style="color: red;"><b>WARNING</b></span> : Pour la suite, tu utiliseras le type Int pour les entiers. En Haskell Int /= Integer. La différence se trouvant dans le nombre de bits de codage. Int est codé sur 32/64 bits, tandis qu'un Integer est codé sur un nombre suffisant de bits pouvoir représenter le nombre.
			<h2>Définition des types et valeurs</h2>
			<h3>Création des types</h3>
			Le programme nécessite que tu définisses quelques types :
			<ul>
				<li>Les <b>positions (Position)</b> sur un plan : un wrapper de tuple d'Int</li>
				<li>Les <b>commandes (Command)</b> disponibles, un énuméré de valeurs</li>
				<li>Les <b>directions (Direction)</b> disponibles, un énuméré de valeurs</li>
				<li>Les <b>tondeuses (Mower)</b>, constituées d'une position et d'une direction initiale</li>
				<li>Le <b>terrain (Field)</b>, constitué d'une position (le coin haut droit), et d'une liste de tondeuse, pour la gestion des collisions</li>
				<li>Les <b>joueurs (Player)</b>, constitué d'une tondeuse et d'une liste de commandes</li>
				<li>Une <b>configuration de jeu (Board)</b> constitué d'un champs et d'une liste de joueurs</li>
			</ul>
			<p>
				Haskell propose plusieurs méthodes pour la définition de types, notamment :
				<br />
				1. <code>newtype</code> permet de définir un type à partir d'un seul autre type seulement. Ce nouveau type défini a une empreinte à compile-time, mais n'existera plus à runtime, et sera considéré comme son type "englobé".
				<p>
					Exemple : <code>newtype Label = Label String</code>
					<br />
					Label existe à la compilation, mais sera remplacé par un type <code>String</code> à l'exécution.
				</p>
				2. <code>data</code> qui permet de définir des types composés d'un ou plusieurs types, avec une empreinte à l'exécution.
				<p>
					Exemple : <code>data Event = Event { name :: String, id :: Int }</code>
					<br />
					Les noms des valeurs composées permettent d'y accéder facilement, ainsi <code>let n = name e where e = Event ("event" 26)</code> permet d'affecter "event" à la constante n. On accède à la valeur <code>name</code> de l'Event <code>e</code>
				</p>
				<p><b><span style="color: red;">HINT : Position sera définie avec <code>newtype</code>, tous les autres types le seront avec <code>data</span></code></b></p>
			</p>
			<h3>Instanciation des Typeclasses</h3>
			<p>
				Certains types ont besoins de porter quelques propriétés :
				<ul>
					<li>Les <code>Position</code> doivent être comparables</li>
					<li>Les <code>Command</code> et les <code>directions</code> doivent pouvoir être affichées à l'écran, comparables et énumérées</li>
					<li>Les <code>Mower</code> doivent pouvoir être affichées à l'écran, comparables et énumérées</li>
					<li>Les Field, Player et Board doivent pouvoir être affichés à l'écran et comparables</li>
				</ul>
				<span style="color: red"><b>HINT : Le mot clé <code>deriving</code> est ton ami</b></span>
			</p>
			<p>
				En plus de ça, il faut :
				<ul>
					<li>Les <code>Mower</code> soient affichables sous la forme "Mower @ (x, y) facing D", avec x et y les coordonées de sa position, et D sa direction</li>
					<li>Les <code>Position</code> soient affichables sous la forme "(x, y)", soient un Monoide, et soient ordonnables</li>
				</ul>
			</p>
			<h2>Définition des fonctions</h2>
			<h3>"Factories"</h3>
			Ecrire les fonctions suivantes :
			<p>
				1. <code>makePosition</code>, qui prend en entrée deux entiers x et y, et qui retourne une position seulement si les entiers sont positifs.
			</p>
			<p>
				2. <code>toCommand</code>, qui prend en entrée un caractère et retourne la commande associée.
			</p>
			<p>
				3. <code>makeCommands</code>, qui prend en entrée une chaine de caractères et retourne une liste de <code>potentielles commandes.</code>
			</p>
			<p>
				4. <code>makeEmptyField</code>, qui prend en entrée deux entiers x et y, et qui retourne un terrain vide de tondeuse, seulement si la position à x, y est correcte.
			</p>
			<p>
				5. <code>makeMower</code>, qui prend en entrée deux entiers x et y, et une direction, et qui retourne une tondeuse à la position et direction indiqué, seulement si la position est valide.
			</p>
			<p>
				6. <code>makePlayer</code>, qui prend en entrée une tondeuse et une liste de <code>commandes potentielles</code> et retourne un Player si les commandes sont définies.
			</p>
			<p>
				7. <code>toDirection</code>, qui prend en entrée un caractère et retourne la direction associée.
			</p>
			<p>
				La fonction de création du Board sera implémentée plus tard, car celle-ci nécessite une gestion d'état.
			</p>

			<h3>Execution des commandes</h3>
			Ecrire les fonctions suivantes :
			<p>
				1. <code>turnLeft</code>, qui retourne une tondeuse avec la direction qui convient.
			</p>
			<p>
				2. <code>turnRight</code>, qui retourne une tondeuse avec la direction qui convient.
			</p>
			<p>
				3. <code>forward</code>, qui retourne une tondeuse avec la position qui convient.
				<span style="color: red;"><b>HINT : N'oubliez pas que Position est un monoide...</b></span>
			</p>
			<p>
				4. <code>isValidPosition</code>, qui retourne un booléen. La position est considérée valide, si elle est dans le Field, et que la position n'est pas déjà occupée par une tondeuse.
			</p>
			<p>
				5. <code>forwardIfTargetPositionIsValid</code>, qui retourne une tondeuse à l'emplacement cible, ou au même emplacement.
			</p>
			<p>
				6. <code>computeCommand</code>, qui retourne une tondeuse sur laquelle a été exécutée la commande.
			</p>
			<p>
				7. <code>computeCommands</code>, qui retourne une monade State qui pour une tondeuse en entrée :
				<ul>
					<li>
						<b>s'il n'y a pas de commandes à exécuter :</b> ne retourne pas de valeur, et retourne la même tondeuse en guise d'état
					</li>
					<li>
						<b>sinon :</b> ne retourne pas de valeur, et retourne une tondeuse après l'exécution de la commande en guise d'état
					</li>
				</ul>
				Je te laisse deviner comment exécuter la suite des commandes !
				<span style="color: red;"><b>HINT : Rapelle toi que c'est une monade...</b></span>
			</p>

			<h3>Un dernier effort...</h3>
			Implémenter les fonctions suivantes :
			<p>
				1. <code>makeBoard</code>, cette fonction permet de construire le terrain de jeu. En utilisant la State Monad, compose la création du Board ;)
			</p>
			<p>
				2. <code>playGame</code>, exécute l'ensemble des commandes pour chacun des players.
			</p>
		</fieldset>
	</body>
</html>